# 4. 쿼리



- 조건절을 이용해 범위 쿼리, 셋의 포함 관계, 부등 관계 쿼리 등을 수행
- 쿼리는 필요할 때마다 도큐먼트 배치를 반환하는 데이터베이스 커서를 반환
- 커서를 이용해 결과를 몇 개 건너뛰거나, 반환하는 결과 수를 제한하거나, 결과를 정렬하는 등 다양한 메타 연산을 수행



## 4.1 find 소개

find 함수는 쿼리에 사용!
쿼리는 컬렉션에서 도큐먼트의 서브셋을 반환

```db.c.find()``` : 조회. 조건이 없다면 ( 빈 쿼리 도큐먼트로 조회) 전체 컬렉션 반환

```
db.users.find({"age": 27})
db.users.find({"age": 27, "username": "john doe"})
```





### 4.1.1 반환받을 키 지정

```
db.users.find({}, {"username": 1, "email": 1, "_id": 0})
```

반환받을 키를 위와 같이 지정 가능 (username, email 받고, _id 리턴 X)



### 4.1.2 제약 사항

쿼리 도큐먼트 값은 반드시 상수여야 한다!

```
db.stock.find({"in_stock": "this.num_sold"}) // 불가능!
```



## 4.2 쿼리 조건

완전 일치 외에도 범위, or절, 부정 조건 등 복잡한 조건 검색 가능!



### 4.2.1 쿼리 조건절

`$gte`,  `$lte`,  `$gt`, `$lt`, `$ne`로 가능!

``` 
db.users.find({"age": {"$gte": 17, "$lt": 20}})
```



### 4.2.2 OR 쿼리

`$in`, `$or`



### 4.2.3 $not

```
db.users.find({"id_num": {"$not": {"$mod": [5, 1]}}})
```

`not` 은 정규 표현식과 함께 사용해 주어진 패턴과 일치하지 않는 도큐먼트를 찾을 때 특히 유용!



## 4.3 형 특정 쿼리

몽고 DB는 도큐먼트 내에서 다양한 데이터형을 사용할 수 있다. 
일부 데이터형은 쿼리 시 형에 특정하게 작동!



### 4.3.1 null

null 은 스스로 일치하는 것을 찾고 + '존재하지 않음' 과도 해당 

도큐먼트이니, 해당 컬럼이 애초에 없을 수 있음!



### 4.3.2 정규 표현식

$regex : 쿼리에서 패턴 일치 문자열을 위한 정규식 기능을 제공한다.
문자열 일치를 유연하게 해줄 수 있다!



### 4.3.3 배열에 쿼리하기

배열 요소 쿼리는 스칼라 쿼리와 같은 방식으로 동작하도록 설계됨!

- 쿼리를 이용해서 일치하는 도큐먼트를 찾을 수 있음 `$find`
- 2개이상의 요소가 일치하는 배열 찾으려면 `$all`
- 특정 요소 쿼리하려면 `key.index` 구문을 이용해 순서 지정 가능
  - `db.food.find({"fruit.2": "peach"})`

#### $size

특정 크기의 배열을 쿼리

#### $slice 연산자

배열 요소의 부분집합을 반환받을 수 있음

```
db.blog.posts.findOne(criteria, {"comments": {"$slice": 10}})
db.blog.posts.findOne(criteria, {"comments": {"$slice": -10}}) // last 10개
db.blog.posts.findOne(criteria, {"comments": {"$slice": [23, 10]}}) // 24부터 10개
```

#### 일치하는 배열 요소의 반환

특정 기준과 일치하는 배열 요소를 원한다면 
$연산자를 사용하여 일치하는 요소를 얻을 수 있다.

```
db.blog.posts.find({"comments.$": 1})
```

각 도큐먼트에서 첫 번째로 일치하는 댓글만 반환한다!



#### 배열 및 범위 쿼리의 상호작용

배열에 대한 범위 쿼리는 주의해야한다!

```
{"x": 5}
{"x": 15}
{"x": 25}
{"x": [5, 25]}
```

와 같은 도큐먼트가 있다고 가정.

```
db.test.find({"x": {"$gt": 10, "$lt": 20}})

{"x": 15}
{"x": [5, 25]}
```

2번째 결과값도 튀어나온다!!

배열의 각각을 본다면 5는 두번째 조건과 일치, 25는 첫 번째 조건과 일치하기 때문!
**-> 배열에 대한 범위 쿼리는 모든 다중 요소 배열과 일치하기에 다른 방법이 필요하다!**

**그렇다면 어떻게할까?**

- "$elemMatch" 연산자를 사용해서 가능!
  - 비배열요소와는 일치하지 않는다.
  - 한 필드에 배열값과 스칼라값을 함께 저장하려면 반드시 이유가 있어야한다!
- 배열을 포함하는 도큐먼트에 범위 쿼리를 할 때는 min 과 max 함수를 사용하면 좋다!



### 4.3.4 내장 도큐먼트에 쿼리하기

내장 도큐먼트 쿼리는 **도큐먼트 전체를 대상으로 하는 방식**과 
**도큐먼트 내 키/값 쌍 각각을 대상으로 하는 방식**으로 나뉜다.

전체 도큐먼트 대상 쿼리는 일반적인 쿼리와 동일하게 작동!

**근데 서브 도큐먼트 전체에 쿼리하려면? 서브 도큐먼트와 정확히 일치해야한다!**
필드까지 일치해야할 필요가 있다.

```
{
	"name": {
		"first": ~~,
		"last": ~~
	},
	"age": 123
}
```

이 때 name 에 다른 필드가 추가되면 전체 도큐먼트가 일치하지 않으므로 쿼리가 더는 작동하지 않는다.

**따라서 내장 도큐먼트에 대한 쿼리는 특정 키로 쿼리하자!**

`name.first: ~~, name.last: ~~`이러면 다른 필드가 추가되어도 여전히 쿼리는 일치 가능!



그런데 내부 구조가 복잡해질수록 일치하는 내장 도큐먼트는 찾기가 어려워진다!

내장 도큐먼트와 쿼리 도큐먼트가 완전히 일치해야하기 때문!

그래서 $elemMatch 를 잘 써야한다~



## 4.4 $where 쿼리

키/값 쌍으로 여러 쿼리를 할 수 있지만 정확히 표현할 수 없는 쿼리도 있다!

$where 절을 사용해서 js 를 쿼리의 일부로 실행 가능! -> 유저가 직접 넣는 건 안되게 막아야 한다.
+시간도 훨씬 느림!





## 4.5 커서(cursor)

데이터베이스는 커서를 사용해 find 의 결과를 반환한다. 
일반적으로 클라 측의 커서 구현체는 쿼리의 결과를 강력하게 제어한다.

shell 에서 커서를 생성하려면 컬렉션에 도큐먼트를 넣고 쿼리한 후 결과를 지역 변수에 할당한다. 

find를 호출할 때 shell 이 바로 쿼리하지 않고, 결과를 요청할 때까지 기다린다!









### 4.5.1 제한, 건너뛰기, 정렬

제한, 건너뛰기, 정렬 옵션을 줄 때는 쿼리가 DB에 전송되기 전에 추가해야 한다.

```
db.c.find().limit(3)
```


### 4.5.2 많은 수의 건너뛰기 피하기

도큐먼트 수가 적을 때는 skip 을 사용해도 무리가 없지만, skip 은 생략된 결과물을 모두 찾아 폐기하므로 느려진다.

대부분의 db는 skip 을 위해 인덱스 안에 메타데이터를 저장하지만, 몽고DB는 아직 해당 기능을 지원하지 않는다. 

-> large skip 은 피해라~

이전에 가져왔던 쿼리 값을 기반으로 다음값을 찾는것을 권장!

`id: {$gt: ~~}`



#### 랜덤으로 도큐먼트 찾기

find 해놓고 random 하게 찾아오지만, 애초에 random 값과 넣어두는게 좋다!



### 4.5.3 종료되지 않는 커서

커서의 두 측면

- 클라이언트가 보는 커서
- 클라이언트 커서가 나타내는 데이터베이스 커서 (서버 커서)



#### 서버 커서

서버측에서 보면 커서는 메모리와 리소스를 점유

이를 종료하기 위해서는 

- 커서는 조건에 일치하는 결과를 모두 살펴본 후에는 스스로 정리
- 커서가 클라이언트측에서 유효영역을 벗어나면 드라이버는 DB에 메시지를 보내 커서를 종료해도 된다고 알린다
- 사용자가 아직 결과를 안살펴보고 + 유효 영역 내이더라도, 10분동안 활동 없다면 커서는 죽는다.

-> 따라서 열린 커서가 수천 개가 될 수 없다.

일부러 커서를 오래 남기고 싶다면 immortal 이라는 함수를 통해서 가능하지만, 리소스를 계속 차지하게 된다!



